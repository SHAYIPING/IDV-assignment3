<!DOCTYPE html>
<style>
  html,body{ margin:0; padding:0; background:#fff; }
  /* 关键：让图随容器宽度缩放 */
  svg{ width:100%; height:auto; display:block; }
</style>

<script>
  function sendHeight(){
    const h = Math.max(
      document.body.scrollHeight, document.documentElement.scrollHeight,
      document.body.offsetHeight, document.documentElement.offsetHeight
    );
    parent.postMessage({ __chartHeight: h }, '*');
  }
  window.addEventListener('load', sendHeight);
  new ResizeObserver(sendHeight).observe(document.body);
</script>

<html lang="zh-CN">
<meta charset="utf-8"/>
<title>D3.js — Probability Density (transition + hover, delayed areas)</title>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<style>
  html,body{margin:0;background:#fff}
  svg{display:block;margin:0 auto;background:#fff}
  text{font-family:"Times New Roman", Georgia, serif; fill:#111}

  .grid line{stroke:#d9d9d9; stroke-width:1}
  .grid path{display:none}

  /* 坐标字号（x、y 刻度） */
  .tick text{font-size:20px}

  .label-x{font-size:18px}
  .label-y{font-size:34px}

  .curve0{stroke:#f0b43a; fill:none; stroke-width:5; stroke-linecap:round}
  .curve1{stroke:#2c8a8f; fill:none; stroke-width:5; stroke-linecap:round}

  .vline{stroke:#222; stroke-dasharray:6 6; stroke-width:3}
  .xline{stroke:#222; stroke-dasharray:6 6; stroke-width:2; stroke-linecap:butt}

  /* ⚠️ 灰色面积不再在 CSS 里设置 opacity，改由 JS 动画控制 fill-opacity */
  .shade{fill:#888;}

  .legend{font-size:28px; font-style:italic}

  /* 命中层：用于捕捉鼠标事件的隐形粗线 */
  .hit{ fill:none; stroke:transparent; stroke-width:18px; pointer-events:stroke }

  /* 悬浮提示样式（SVG 内） */
  .tip-bg{ fill:#fff; stroke:#333; stroke-width:.8; rx:6; ry:6 }
  .tip-txt{ font-size:14px; fill:#111 }
</style>
<body>
<svg id="chart" width="810" height="529"></svg>

<script>
const svg = d3.select("#chart");
const W = 810, H = 529;

/* x轴在 y≈408px；下方 30px 表格带 */
const margin = {top:19, right:36, bottom:72, left:120};
const innerW = W - margin.left - margin.right;
const innerH = 408 - margin.top; // 389
const bandH  = 30;

const g = svg.append("g").attr("transform",`translate(${margin.left},${margin.top})`);

const x = d3.scaleLinear().domain([-2,5]).range([0, innerW]);
const y = d3.scaleLinear().domain([0,0.35]).range([innerH,0]);

/* 像素锚点 -> 数据坐标 */
function pxToData(pointsPx){
  return pointsPx.map(p=>{
    const xi = p.x - margin.left;
    const yi = p.y - margin.top;
    return { x: x.invert(xi), y: y.invert(yi) };
  });
}

const yellowPx = [
  {x:184,y:408},{x:203,y:352},{x:219,y:298},{x:231,y:241},{x:241,y:201},
  {x:269,y:168},{x:306,y:148},{x:346,y:170},{x:371,y:201},{x:392,y:235},
  {x:414,y:271},{x:434,y:304},{x:461,y:338},{x:486,y:363},{x:519,y:388},
  {x:559,y:400},{x:595,y:408},{x:652,y:408},{x:720,y:408}
];
const greenPx = [
  {x:122,y:409},{x:215,y:409},{x:245,y:409},{x:275,y:409},{x:324,y:384},{x:360,y:350},{x:384,y:310},{x:408,y:260},
  {x:433,y:210},{x:458,y:163},{x:472,y:146},{x:480,y:135},{x:495,y:129},
  {x:510,y:135},{x:514,y:140},{x:517,y:142},{x:532,y:163},{x:551,y:196},
  {x:564,y:229},{x:581,y:264},{x:600,y:298},{x:623,y:339},{x:645,y:366},
  {x:676,y:397},{x:714,y:409},{x:773,y:408}
];
const yellow = pxToData(yellowPx);
const green  = pxToData(greenPx);

/* 背景网格（到 x 轴为止） */
g.append("g").attr("class","grid")
  .attr("transform",`translate(0,${innerH})`)
  .call(d3.axisBottom(x).ticks(8).tickSize(-innerH).tickFormat(""));
g.append("g").attr("class","grid")
  .call(d3.axisLeft(y).ticks(8).tickSize(-innerW).tickFormat(""));

/* x轴下表格带 */
const band = g.append("g").attr("transform",`translate(0,${innerH})`);
band.append("rect")
  .attr("x",0).attr("y",0).attr("width",innerW).attr("height",bandH)
  .attr("fill","#fff");
band.selectAll(".vgrid").data(x.ticks(8)).enter().append("line")
  .attr("x1",d=>x(d)).attr("x2",d=>x(d)).attr("y1",0).attr("y2",bandH)
  .attr("stroke","#e6e6e6");
/* 顶边虚线交给后面的 x 轴虚线绘制（两段），此处不画整段 */
band.append("line")
  .attr("x1",0).attr("x2",innerW).attr("y1",bandH).attr("y2",bandH)
  .attr("stroke","#d9d9d9").attr("stroke-width",1);

/* y 轴仅保留数字 */
const yAxis = g.append("g").call(d3.axisLeft(y).ticks(8));
yAxis.select(".domain").remove();
yAxis.selectAll(".tick line").remove();

/* x 轴数字放在底边线框下方 */
g.append("g")
  .attr("transform",`translate(0,${innerH + bandH + 18})`)
  .call(d3.axisBottom(x).ticks(8).tickSize(0))
  .select(".domain").remove();

/* 标签 */
g.append("text").attr("class","label-x")
  .attr("x", innerW/2).attr("y", innerH+110)
  .attr("text-anchor","middle").text("X");
g.append("text").attr("class","label-y")
  .attr("transform","rotate(-90)")
  .attr("x", -innerH/2).attr("y", -90)
  .attr("text-anchor","middle").text("Probability Density");

/* 曲线（curveBasis） */
const lineBasis = d3.line().x(d=>x(d.x)).y(d=>y(d.y)).curve(d3.curveBasis);

/* ===== 绘制曲线 + 渐入动画 ===== */
const curveLayer = g.append("g");

const pathYellow = curveLayer.append("path")
  .attr("class","curve0")
  .attr("d", lineBasis(yellow))
  .attr("opacity",0);

const pathGreen = curveLayer.append("path")
  .attr("class","curve1")
  .attr("d", lineBasis(green))
  .attr("opacity",0);

/* 灰色面积（稍后淡入，使用 fill-opacity 动画） */
const cutA = 0.8, cutB = 1.35;
const areaBasis = d3.area().x(d=>x(d.x)).y0(y(0)-1).y1(d=>y(d.y)).curve(d3.curveBasis);

const areaYellow = g.append("path").attr("class","shade")
  .attr("d", areaBasis(yellow))
  .style("fill-opacity", 0);
const areaGreen  = g.append("path").attr("class","shade")
  .attr("d", areaBasis(green))
  .style("fill-opacity", 0);

/* 裁剪（左右） */
g.append("clipPath").attr("id","clip-right").append("rect")
  .attr("x",x(cutA)).attr("y",0).attr("width",innerW - x(cutA)).attr("height",innerH);
g.append("clipPath").attr("id","clip-left").append("rect")
  .attr("x",0).attr("y",0).attr("width",x(cutB)).attr("height",innerH);

areaYellow.attr("clip-path","url(#clip-right)");
areaGreen .attr("clip-path","url(#clip-left)");

/* x 轴虚线（两段，中间留空；在曲线之上） */
const xAxisDashes = g.append("g");
const xDashL = xAxisDashes.append("line").attr("class","xline")
  .attr("x1",0).attr("x2",x(cutA)).attr("y1",innerH).attr("y2",innerH).attr("opacity",0);
const xDashR = xAxisDashes.append("line").attr("class","xline")
  .attr("x1",x(cutB)).attr("x2",innerW).attr("y1",innerH).attr("y2",innerH).attr("opacity",0);

/* 两条竖直虚线（到底即止） */
const vL = g.append("line").attr("class","vline")
  .attr("x1",x(cutA)).attr("x2",x(cutA)).attr("y1",0).attr("y2",innerH).attr("opacity",0);
const vR = g.append("line").attr("class","vline")
  .attr("x1",x(cutB)).attr("x2",x(cutB)).attr("y1",0).attr("y2",innerH).attr("opacity",0);

/* ===== 动画：路径逐笔绘制 + 透明度淡入 ===== */
function drawIn(pathSel, duration=1200, delay=0){
  const len = pathSel.node().getTotalLength();
  pathSel
    .attr("stroke-dasharray",len+" "+len)
    .attr("stroke-dashoffset",len)
    .transition().delay(delay).duration(duration)
    .attr("stroke-dashoffset",0)
    .attr("opacity",1);
}
function fadeIn(sel, duration=800, delay=0){
  sel.transition().delay(delay).duration(duration).attr("opacity",1);
}
/* 面积淡入（使用 fill-opacity，避免与曲线/虚线互相影响） */
function fadeInArea(sel, duration=800, delay=1200, toOpacity=0.45){
  sel.transition().delay(delay).duration(duration).style("fill-opacity", toOpacity);
}

/* 曲线先出现 */
drawIn(pathYellow,1200,200);   // 最早结束：200+1200=1400ms
drawIn(pathGreen,1200,350);    // 最晚结束：350+1200=1550ms

/* 虚线稍后淡入 */
fadeIn(xDashL,600,500);
fadeIn(xDashR,600,500);
fadeIn(vL,600,500);
fadeIn(vR,600,500);

/* ⚠️ 灰色面积在曲线完全绘制后才淡入（>=1550ms 之后） */
fadeInArea(areaYellow, 800, 1000); // 黄色面积更晚出现
fadeInArea(areaGreen,  800, 1100); // 绿色面积再晚一点

/* ===== 悬停交互：显示最近点坐标 ===== */
/* 命中层：隐形粗线用来捕捉鼠标 */
curveLayer.append("path")
  .attr("class","hit")
  .attr("d", lineBasis(yellow))
  .on("mouseenter", () => showTip('yellow'))
  .on("mousemove", (e)=> moveTip(e,'yellow'))
  .on("mouseleave", hideTip);

curveLayer.append("path")
  .attr("class","hit")
  .attr("d", lineBasis(green))
  .on("mouseenter", () => showTip('green'))
  .on("mousemove", (e)=> moveTip(e,'green'))
  .on("mouseleave", hideTip);

/* 提示框与高亮点（最上层） */
const tipLayer = g.append("g");
const tipGroup = tipLayer.append("g").style("display","none");
const tipBg = tipGroup.append("rect").attr("class","tip-bg").attr("width",132).attr("height",40);
const tipTxt1 = tipGroup.append("text").attr("class","tip-txt").attr("x",8).attr("y",16);
const tipTxt2 = tipGroup.append("text").attr("class","tip-txt").attr("x",8).attr("y",32);
const tipDot  = tipLayer.append("circle").attr("r",5).style("display","none");

/* 最近点查找（假设 x 单调） */
function nearestPoint(arr, x0){
  let lo=0, hi=arr.length-1;
  while(hi - lo > 1){
    const mid = (lo+hi)>>1;
    if(arr[mid].x < x0) lo=mid; else hi=mid;
  }
  const a = arr[lo], b = arr[hi];
  return (Math.abs(a.x-x0) <= Math.abs(b.x-x0)) ? a : b;
}
const curves = {
  yellow: { data: yellow, color: "#f0b43a" },
  green:  { data: green,  color: "#2c8a8f" }
};
function showTip(which){
  tipGroup.style("display", null);
  tipDot.style("display", null).attr("fill", curves[which].color).attr("stroke","#111").attr("stroke-width",1);
}
function moveTip(event, which){
  const pt = d3.pointer(event, g.node());
  const x0 = x.invert(pt[0]);
  const d  = nearestPoint(curves[which].data, x0);
  const sx = x(d.x), sy = y(d.y);

  tipDot.attr("cx", sx).attr("cy", sy);
  tipTxt1.text(`x = ${d.x.toFixed(2)}`);
  tipTxt2.text(`y = ${d.y.toFixed(3)}`);

  const boxW = 132, boxH = 40;
  let tx = sx + 10, ty = sy - boxH - 8;
  if (tx + boxW > innerW) tx = sx - boxW - 12;
  if (ty < 0) ty = sy + 12;
  tipGroup.attr("transform", `translate(${tx},${ty})`);
}
function hideTip(){
  tipGroup.style("display","none");
  tipDot.style("display","none");
}

/* 图例 */
const legend = g.append("g").attr("transform",`translate(${innerW-275},20)`);
legend.append("line").attr("x1",-40).attr("x2",25).attr("y1",10).attr("y2",10).attr("class","curve0");
legend.append("text").attr("class","legend").attr("x",70).attr("y",18).text("p(x, y = 0) * ν(x)");
legend.append("line").attr("x1",-40).attr("x2",25).attr("y1",46).attr("y2",46).attr("class","curve1");
legend.append("text").attr("class","legend").attr("x",70).attr("y",54).text("p(x, y = 1) * ν(x)");
</script>
</body>
</html>

